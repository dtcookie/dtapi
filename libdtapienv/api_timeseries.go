/*
 * Dynatrace Environment API
 *
 * Documentation of the Dynatrace REST API. Refer to the [help page](https://www.dynatrace.com/support/help/shortlink/section-api) to read about use-cases and examples.
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package dtapienv

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type TimeseriesApiService service

/*
TimeseriesApiService Creates a new custom metric.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param timeseriesIdentifier The ID for the new metric. It must start with the `custom:` prefix.   If you use the ID of an existing metric the respective parameters will be updated.
 * @param optional nil or *CreateCustomTimeseriesOpts - Optional Parameters:
 * @param "TimeseriesRegistrationMessage" (optional.Interface of TimeseriesRegistrationMessage) -  The body of the request, containing metric parameters.
@return TimeseriesDefinition
*/

type CreateCustomTimeseriesOpts struct {
    TimeseriesRegistrationMessage optional.Interface
}

func (a *TimeseriesApiService) CreateCustomTimeseries(ctx context.Context, timeseriesIdentifier string, localVarOptionals *CreateCustomTimeseriesOpts) (TimeseriesDefinition, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue TimeseriesDefinition
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/timeseries/{timeseriesIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"timeseriesIdentifier"+"}", fmt.Sprintf("%v", timeseriesIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.TimeseriesRegistrationMessage.IsSet() {
		localVarOptionalTimeseriesRegistrationMessage, localVarOptionalTimeseriesRegistrationMessageok := localVarOptionals.TimeseriesRegistrationMessage.Value().(TimeseriesRegistrationMessage)
		if !localVarOptionalTimeseriesRegistrationMessageok {
			return localVarReturnValue, nil, reportError("timeseriesRegistrationMessage should be TimeseriesRegistrationMessage")
		}
		localVarPostBody = &localVarOptionalTimeseriesRegistrationMessage
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarQueryParams.Add("Api-Token", key)
		}
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TimeseriesDefinition
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TimeseriesApiService Deletes a custom metric.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param timeseriesIdentifier The ID of the metric to be deleted.
*/
func (a *TimeseriesApiService) DeleteCustomTimeseries(ctx context.Context, timeseriesIdentifier string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/timeseries/{timeseriesIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"timeseriesIdentifier"+"}", fmt.Sprintf("%v", timeseriesIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarQueryParams.Add("Api-Token", key)
		}
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
TimeseriesApiService Lists all metric definitions, along with parameters of each metric.
You can specify filtering paramters to return only matched metrics. If no parameters are specified, the call will list all the defined and exposed metrics.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GetAllTimeseriesDefinitionsOpts - Optional Parameters:
 * @param "Source" (optional.String) -  Metric type. Allowed values are `BUILTIN`, `PLUGIN`, and `CUSTOM`.
 * @param "DetailedSource" (optional.String) -  The feature, where metrics originate, such as Synthetic or RUM.
@return []TimeseriesDefinition
*/

type GetAllTimeseriesDefinitionsOpts struct {
    Source optional.String
    DetailedSource optional.String
}

func (a *TimeseriesApiService) GetAllTimeseriesDefinitions(ctx context.Context, localVarOptionals *GetAllTimeseriesDefinitionsOpts) ([]TimeseriesDefinition, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue []TimeseriesDefinition
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/timeseries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Source.IsSet() {
		localVarQueryParams.Add("source", parameterToString(localVarOptionals.Source.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DetailedSource.IsSet() {
		localVarQueryParams.Add("detailedSource", parameterToString(localVarOptionals.DetailedSource.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarQueryParams.Add("Api-Token", key)
		}
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []TimeseriesDefinition
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TimeseriesApiService Lists all available metric data points, matching specified parameters.
Provides advanced filtering possibilities, comparing to the &#x60;GET /timeseries/{metricIdentifier}&#x60; request.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param timeseriesIdentifier Case-sensitive identifier of the timeseries, where you want to read parameters and data points.
 * @param optional nil or *ReadTimeseriesComplexOpts - Optional Parameters:
 * @param "TimeseriesQueryMessage" (optional.Interface of TimeseriesQueryMessage) -  JSON body of the request, containing parameters to identify the required data points.
@return TimeseriesQueryResultWrapper
*/

type ReadTimeseriesComplexOpts struct {
    TimeseriesQueryMessage optional.Interface
}

func (a *TimeseriesApiService) ReadTimeseriesComplex(ctx context.Context, timeseriesIdentifier string, localVarOptionals *ReadTimeseriesComplexOpts) (TimeseriesQueryResultWrapper, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue TimeseriesQueryResultWrapper
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/timeseries/{timeseriesIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"timeseriesIdentifier"+"}", fmt.Sprintf("%v", timeseriesIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.TimeseriesQueryMessage.IsSet() {
		localVarOptionalTimeseriesQueryMessage, localVarOptionalTimeseriesQueryMessageok := localVarOptionals.TimeseriesQueryMessage.Value().(TimeseriesQueryMessage)
		if !localVarOptionalTimeseriesQueryMessageok {
			return localVarReturnValue, nil, reportError("timeseriesQueryMessage should be TimeseriesQueryMessage")
		}
		localVarPostBody = &localVarOptionalTimeseriesQueryMessage
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarQueryParams.Add("Api-Token", key)
		}
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TimeseriesQueryResultWrapper
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
TimeseriesApiService Gets the parameters of the specified metric and optionally data points.
To obtain data points, set **includeData** to &#x60;true&#x60;.   You can obtain either data points or the scalar result of the specified timeseries, depending on the **queryMode**.   To obtain data points you must specify the timeframe, either as **relativeTime** or as combination of **startTimestamp** and **endTimestamp**. You must also provide **aggregationType**, supported by the metric.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param timeseriesIdentifier Case-sensitive identifier of the timeseries, where you want to read parameters and data points.
 * @param optional nil or *ReadTimeseriesDataOpts - Optional Parameters:
 * @param "IncludeData" (optional.Bool) -  Flag to include data points to the response.    To obtain data points you must specify the timeframe and aggregation type.
 * @param "AggregationType" (optional.String) -  The aggregation type for the resulting data points.   If the requested metric doesn't support the specified aggregation, the request will result in an error.
 * @param "StartTimestamp" (optional.Int64) -  Start timestamp of the requested timeframe, in milliseconds (UTC). The start time must be earlier than the end time.
 * @param "EndTimestamp" (optional.Int64) -  End timestamp of the requested timeframe, in milliseconds (UTC). End time must be later than the start time.   If later than the current time, Dynatrace automatically uses current time instead.
 * @param "Predict" (optional.Bool) -  Used to predict future data points.
 * @param "RelativeTime" (optional.String) -  Relative timeframe, back from the current time.
 * @param "QueryMode" (optional.String) -  The type of result that the call should return. Valid result modes are:  `series`: returns all the data points of the timeseries in specified timeframe.  `total`: returns one scalar value for the specified timeframe.   By default, the `series` mode is used.
 * @param "Entity" (optional.Interface of []string) -  Filters requested data points by entity which should deliver them.   Allowed values are Dynatrace entity IDs. You can find them in the URL of the corresponding Dynatrace entity page, for example, `HOST-007`.   If the selected entity doesn't support the requested timeseries, the request will result in an error.
 * @param "Tag" (optional.Interface of []string) -  Filters the resulting set of applications by the specified tag.   Use multiple tag parameters to combine multiple tag filters using the logical operator AND.   In case of key-value tags, such as imported AWS or CloudFoundry tags use following format: `[context]key:value`.
 * @param "Percentile" (optional.Int32) -  In case of the percentile aggregation type, this parameter specifies which percentile of the selected response time metric should be delivered. Valid values for percentile are between 1 and 99.   Please keep in mind that percentile export is only possible for response-time based metrics such as application and service response times.
@return []TimeseriesQueryResult
*/

type ReadTimeseriesDataOpts struct {
    IncludeData optional.Bool
    AggregationType optional.String
    StartTimestamp optional.Int64
    EndTimestamp optional.Int64
    Predict optional.Bool
    RelativeTime optional.String
    QueryMode optional.String
    Entity optional.Interface
    Tag optional.Interface
    Percentile optional.Int32
}

func (a *TimeseriesApiService) ReadTimeseriesData(ctx context.Context, timeseriesIdentifier string, localVarOptionals *ReadTimeseriesDataOpts) ([]TimeseriesQueryResult, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue []TimeseriesQueryResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/timeseries/{timeseriesIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"timeseriesIdentifier"+"}", fmt.Sprintf("%v", timeseriesIdentifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeData.IsSet() {
		localVarQueryParams.Add("includeData", parameterToString(localVarOptionals.IncludeData.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AggregationType.IsSet() {
		localVarQueryParams.Add("aggregationType", parameterToString(localVarOptionals.AggregationType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartTimestamp.IsSet() {
		localVarQueryParams.Add("startTimestamp", parameterToString(localVarOptionals.StartTimestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndTimestamp.IsSet() {
		localVarQueryParams.Add("endTimestamp", parameterToString(localVarOptionals.EndTimestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Predict.IsSet() {
		localVarQueryParams.Add("predict", parameterToString(localVarOptionals.Predict.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RelativeTime.IsSet() {
		localVarQueryParams.Add("relativeTime", parameterToString(localVarOptionals.RelativeTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QueryMode.IsSet() {
		localVarQueryParams.Add("queryMode", parameterToString(localVarOptionals.QueryMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Entity.IsSet() {
		localVarQueryParams.Add("entity", parameterToString(localVarOptionals.Entity.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Percentile.IsSet() {
		localVarQueryParams.Add("percentile", parameterToString(localVarOptionals.Percentile.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarQueryParams.Add("Api-Token", key)
		}
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []TimeseriesQueryResult
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
